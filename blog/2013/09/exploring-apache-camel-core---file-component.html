<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Zemian's Blog - Exploring Apache Camel Core - File Component</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <meta name="keywords" content="">
    <meta name="generator" content="JBake">

    <!-- Le styles -->
    <link href="../../../css/bootstrap.min.css" rel="stylesheet">
    <link href="../../../css/asciidoctor.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link href="../../../css/prettify.css" rel="stylesheet">

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!--<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">-->
    <link rel="shortcut icon" href="../../../favicon.ico">
  </head>
  <body onload="prettyPrint()">
    <div id="wrap">
	
	<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../../../">Zemian's Blog</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="../../../index.html">Home</a></li>
            <li><a href="../../../about.html">About</a></li>
            <li><a href="../../../archive.html">Archive</a></li>
            <li><a href="../../..//tags">Tags</a></li>
            <li><a href="../../../feed.xml">Subscribe</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>
    <div class="container">	
	<div class="page-header">
		<h1>Exploring Apache Camel Core - File Component</h1>
	</div>

	<p><em>04 September 2013</em>, tags: 
	    <a href="../../../tags/camel.html">camel</a> 
	</p>

	<p><div class="paragraph">
<p>A file poller is a very useful mechanism to solve common IT problems. Camel&#8217;s built-in <code>file</code> component is extremely flexible, and there are many options available for configuration. Let&#8217;s cover few common usages here.</p>
</div>
<div class="sect1">
<h2 id="_polling_a_directory_for_input_files">Polling a directory for input files</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Here is a typical Camel <code>Route</code> used to poll a directory for input files on every second.</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre>import org.slf4j.*;
import org.apache.camel.*;
import org.apache.camel.builder.*;
import java.io.*;

public class FileRouteBuilder extends RouteBuilder {
    static Logger LOG = LoggerFactory.getLogger(FileRouteBuilder.class);
    public void configure() {
        from("file://target/input?delay=1000")
        .process(new Processor() {
            public void process(Exchange msg) {
                File file = msg.getIn().getBody(File.class);
                LOG.info("Processing file: " + file);
            }
        });
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>Run this with following</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre>mvn compile exec:java -Dexec.mainClass=org.apache.camel.main.Main -Dexec.args='-r camelcoredemo.FileRouteBuilder'</pre>
</div>
</div>
<div class="paragraph">
<p>The program will begin to poll your <code>target/input</code> folder under your current directory, and wait for incoming files. To test with input files, you would need to open another terminal, and then create some files as follow.</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre>echo 'Hello 1' &gt; target/input/test1.txt
echo 'Hello 2' &gt; target/input/test2.txt</pre>
</div>
</div>
<div class="paragraph">
<p>You should now see the first prompt window start to picking up the files and pass to the next <code>Processor</code> step. In the <code>Processor</code>, we obtain the <code>File</code> object from the message body. It then simply logs it&#8217;s file name. You may hit <code>CTRL+C</code> when you are done.</p>
</div>
<div class="paragraph">
<p>There many configurable options from <code>file</code> componet you may use in the URL, but most of the default settings are enough to get you going as simple case above. Some of these default behavior is such that if the input folder doesn&#8217;t exists, it will create it. And when the file is done processing by the <code>Route</code>, it will be moved into a <code>.camel</code> folder. If you don&#8217;t want the file at all after processing, then set <code>delete=true</code> in the URL.</p>
</div>

</div>
</div>
<div class="sect1">
<h2 id="_read_in_the_file_content_and_converting_to_different_types">Read in the file content and converting to different types</h2>
<div class="sectionbody">
<div class="paragraph">
<p>By default, the <code>file</code> component will create a <code>org.apache.camel.component.file.GenericFile</code> object for each file found and pass it down your <code>Route</code> as message body. You may retrieve all your file information through this object. Or alternatively, you may also use the <code>Exchange</code> API to auto convert the message body object to a type you expect to receive (eg: as with <code>msg.getIn().getBody(File.class)</code>). In above example, the <code>File</code> is a type you expect to get from the message body, and Camel hence will try to convert it for you. The Camel uses the context&#8217;s registry space to pre-registered many <code>TypeConverter</code>'s that can handle most of the common data types (like Java primative etc) conversion. These <code>TypeConverter</code><em>s</em> are powerful way to make your <code>Route</code> and <code>Processor</code> more flexbile and portable.</p>
</div>
<div class="paragraph">
<p>Camel will not only convert just your <code>File</code> object from message body, but it can also read the file content. If your files are character text based, then you can simply do this.</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre>        from("file://target/input?charset=UTF-8")
        .process(new Processor() {
            public void process(Exchange msg) {
                String text = msg.getIn().getBody(String.class);
                LOG.info("Processing text: " + text);
            }
        });</pre>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s it! Simply specify <code>String</code> type, and Camel will read your file in and pass the entire file text content as body message. You may even use the <code>charset</code> to change the encoding.</p>
</div>
<div class="paragraph">
<p>If you are dealing with binary file, then simply try <code>byte[] bytes = msg.getIn().getBody(byte[].class);</code> conversion instead. Pretty cool huh?</p>
</div>

</div>
</div>
<div class="sect1">
<h2 id="_polling_and_processing_large_files">Polling and processing large files</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When working with large files, there few options in <code>file</code> componet that you might want to use to ensure proper handling. For example, you might want to move the input file into a <code>staging</code> folder before the <code>Route</code> starts the processing; and when it&#8217;s done, move it to a <code>.completed</code> folder.</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre>        from("file://target/input?preMove=staging&amp;move=.completed")
        .process(new Processor() {
            public void process(Exchange msg) {
                File file = msg.getIn().getBody(File.class);
                LOG.info("Processing file: " + file);
            }
        });</pre>
</div>
</div>
<div class="paragraph">
<p>To feed input files properly into the polling folder, it&#8217;s best if the sender generates the input files in a temporary folder first, and only when it&#8217;s ready then move it into the polling folder. This will minimize reading an incomplete file by the <code>Route</code> if the input file might take times to generate. Also another solution to this is to config <code>file</code> endpoint to only read the polling folder when there is a signal or ready marker file exists. For example:</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre>        from("file://target/input?preMove=staging&amp;move=.completed&amp;doneFileName=ReadyFile.txt")
        .process(new Processor() {
            public void process(Exchange msg) {
                File file = msg.getIn().getBody(File.class);
                LOG.info("Processing file: " + file);
            }
        });</pre>
</div>
</div>
<div class="paragraph">
<p>Above will only read the <code>target/input</code> folder when there is a <code>ReadyFile.txt</code> file exists. The marker file can be just an empty file, and it will be removed by Camel after polling. This solution would allow the sender to generate input files in however long time it might take.</p>
</div>
<div class="paragraph">
<p>Another concern with large file processing is to avoid loading entire file content into memory for processing. To be more practical, you want to split the file into records (eg: per line) and process it one by one (or called "streaming"). Here is how you would do that using Camel.</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre>        from("file://target/input?preMove=staging&amp;move=.completed")
        .split(body().tokenize("\n"))
        .streaming()
        .process(new Processor() {
            public void process(Exchange msg) {
                String line = msg.getIn().getBody(String.class);
                LOG.info("Processing line: " + line);
            }
        });</pre>
</div>
</div>
<div class="paragraph">
<p>This <code>Route</code> will allow you to process large size file without cosuming too much memory and process it line by line very efficiently.</p>
</div>

</div>
</div>
<div class="sect1">
<h2 id="_writing_messages_back_into_file">Writing messages back into file</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>file</code> component can also be used to write messages into files. Recall that we may use <code>dataset</code> component to generate sample messages. We will use that to feed the <code>Route</code> and send to the <code>file</code> component so you can see that each message generated will be saved into a file.</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre>package camelcoredemo;

import org.slf4j.*;
import org.apache.camel.*;
import org.apache.camel.builder.*;
import org.apache.camel.main.Main;
import org.apache.camel.component.dataset.*;

public class FileDemoCamel extends Main {
    static Logger LOG = LoggerFactory.getLogger(FileDemoCamel.class);
    public static void main(String[] args) throws Exception {
        FileDemoCamel main = new FileDemoCamel();
        main.enableHangupSupport();
        main.addRouteBuilder(createRouteBuilder());
        main.bind("sampleGenerator", createDataSet());
        main.run(args);
    }
    static RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from("dataset://sampleGenerator")
                .to("file://target/output");
            }
        };
    }
    static DataSet createDataSet() {
        return new SimpleDataSet();
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>Compile and run it</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre>mvn compile exec:java -Dexec.mainClass=camelcoredemo.FileDemoCamel</pre>
</div>
</div>
<div class="paragraph">
<p>Upon complete you will see that 10 files would be generated in <code>target/output</code> folder with
file name in <code>ID-&lt;hostname&gt;-&lt;unique-number&gt;-&lt;msg-seq-num&gt;</code> format.</p>
</div>
<div class="paragraph">
<p>There are more options availabe from <a href="http://camel.apache.org/file2.html">File</a> component
that you may explore.
<a href="http://saltnlight5.blogspot.com/2013/08/getting-started-with-apache-camel-using.html">Try it out with a Route</a>
and see it for yourself.</p>
</div>

</div>
</div>


</p>

	<hr />
	
		</div>
		<div id="push"></div>
    </div>
    
    <div id="footer">
      <div class="container">
        <p class="muted credit">&copy; 2011 - 2019 Zemian Deng All Rights Reserved | Mixed with <a href="http://getbootstrap.com/">Bootstrap v3.1.1</a> | Baked with <a href="http://jbake.org">JBake v2.6.4</a></p>
      </div>
    </div>
    
    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../../../js/jquery-1.11.1.min.js"></script>
    <script src="../../../js/bootstrap.min.js"></script>
    <script src="../../../js/prettify.js"></script>
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-135626598-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-135626598-1');
    </script>

  </body>
</html>